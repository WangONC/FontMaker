using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using FontMaker.Data.Models;

namespace FontMaker.Exporters
{
    /// <summary>
    /// C/C++ 字体文件导出器
    /// </summary>
    public class CExporter
    {
        private string _filePath;

        public CExporter(string filePath)
        {
            _filePath = filePath;
        }

        /// <summary>
        /// 导出字体数据为C头文件格式
        /// </summary>
        /// <param name="fontData">字体数据</param>
        /// <param name="fontName">字体名称</param>
        /// <returns>是否导出成功</returns>
        public bool Export(FontBitmapData fontData, string fontName)
        {
            try
            {
                var content = GenerateCContent(fontData, fontName);
                File.WriteAllText(_filePath, content, Encoding.UTF8);
                return true;
            }
            catch (Exception)
            {
                return false;
            }
        }

        /// <summary>
        /// 生成C格式的字体内容
        /// </summary>
        private string GenerateCContent(FontBitmapData fontData, string fontName)
        {
            var sb = new StringBuilder();
            var metadata = fontData.Metadata;
            var characters = fontData.Characters;
            int charCount = characters.Count;

            // 文件头注释
            sb.AppendLine("/*******************************************************************************");
            sb.AppendLine("* This file is generated by the Bitmap FontMaker.");
            sb.AppendLine("* GitHub: https://github.com/WangONC/FontMaker");
            sb.AppendLine($"* Generated: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
            sb.AppendLine("*******************************************************************************/");

            // 字体基本参数宏定义
            sb.AppendLine($"#define FONT_MONOSPACE  {(metadata.IsFixedWidth ? 1 : 0)}    // 字体类型: 1=等宽字体, 0=变宽字体");
            sb.AppendLine($"#define FONT_WIDTH      {metadata.MaxCharacterWidth}    // 字符宽度(像素)");
            sb.AppendLine($"#define FONT_HEIGHT     {metadata.MaxCharacterHeight}   // 字符高度(像素)");
            sb.AppendLine($"#define FONT_BPP        {metadata.BitsPerPixel}    // 每像素位数: 1=黑白, 2=4级灰度, 4=16级灰度, 8=256级灰度");
            sb.AppendLine($"#define FONT_PITCH      {(metadata.MaxCharacterWidth * metadata.BitsPerPixel + 7) / 8}    // 每行字节数(向上取整)");
            sb.AppendLine($"#define FONT_CHAR_COUNT {charCount}   // 字符总数");
            sb.AppendLine();
            
            // 数据格式日志
            sb.AppendLine("// 数据格式说明:");
            sb.AppendLine($"// 字体: {metadata.FontFamily}");
            sb.AppendLine($"// 尺寸: {metadata.FontSize}px");
            sb.AppendLine($"// 画布: {metadata.CanvasWidth}x{metadata.CanvasHeight}");
            sb.AppendLine($"// 扫描方式: {(metadata.IsHorizontalScan ? "水平扫描" : "垂直扫描")}");
            sb.AppendLine($"// 位序: {(metadata.IsHighBitFirst ? "从左到右" : "从右到左")}");
            sb.AppendLine($"// 宽度模式: {(metadata.IsFixedWidth ? "固定宽度" : "可变宽度")}");
            sb.AppendLine($"// 字符集: {metadata.CharsetName}");
            sb.AppendLine();

            // 添加数据结构和读取方法说明
            if (!metadata.IsFixedWidth)
            {
                sb.AppendLine("// 可变宽度数据结构说明:");
                sb.AppendLine($"// 宽度字节数: {metadata.WidthBytesCount} (根据最大宽度{metadata.MaxCharacterWidth}确定)");
                sb.AppendLine($"// 高度字节数: {metadata.HeightBytesCount} (根据最大高度{metadata.MaxCharacterHeight}确定)");
                sb.AppendLine($"// 每个字符数据格式: [{metadata.WidthBytesCount}字节宽度] + [{metadata.HeightBytesCount}字节高度] + [点阵数据]");
                sb.AppendLine("// 宽度/高度字节按小端序存储 (低字节在前)");
                sb.AppendLine();
                
                // 添加读取辅助函数
                sb.AppendLine("// 可变宽度字符读取辅助函数");
                sb.AppendLine("typedef struct {");
                sb.AppendLine("    unsigned int width;");
                sb.AppendLine("    unsigned int height;");
                sb.AppendLine("    const unsigned char* data;");
                sb.AppendLine("} char_info_t;");
                sb.AppendLine();
                
                sb.AppendLine($"// 从字符表中读取第index个字符信息");
                sb.AppendLine("char_info_t get_char_info(int index) {");
                sb.AppendLine("    char_info_t info = {0};");
                sb.AppendLine("    const unsigned char* ptr = m_char_bits[index];");
                sb.AppendLine("    ");
                sb.AppendLine("    // 读取宽度 (小端序)");
                GenerateReadBytesCode(sb, "info.width", metadata.WidthBytesCount);
                sb.AppendLine("    ");
                sb.AppendLine("    // 读取高度 (小端序)");
                GenerateReadBytesCode(sb, "info.height", metadata.HeightBytesCount);
                sb.AppendLine("    ");
                sb.AppendLine($"    // 点阵数据起始位置");
                sb.AppendLine($"    info.data = ptr + {metadata.WidthBytesCount + metadata.HeightBytesCount};");
                sb.AppendLine("    ");
                sb.AppendLine("    return info;");
                sb.AppendLine("}");
                sb.AppendLine();
            }
            else
            {
                sb.AppendLine("// 固定宽度数据结构说明:");
                sb.AppendLine("// 每个字符占用固定字节数，无需额外的宽高信息");
                sb.AppendLine($"// 直接使用 m_char_bits[index] 访问第index个字符的点阵数据");
                sb.AppendLine();
            }

            // 字符映射表
            sb.Append("static const unsigned char m_char_table[] = \"");
            foreach (var charInfo in characters)
            {
                char ch = charInfo.Character;
                // 转换为UTF-8字符串表示
                if (ch == '"') sb.Append("\\\"");
                else if (ch == '\\') sb.Append("\\\\");
                else if (ch == '\n') sb.Append("\\n");
                else if (ch == '\r') sb.Append("\\r");
                else if (ch == '\t') sb.Append("\\t");
                else if (ch >= 32 && ch <= 126) sb.Append(ch);
                else
                {
                    // 对于不可显示字符，使用十六进制转义
                    byte[] utf8Bytes = Encoding.UTF8.GetBytes(ch.ToString());
                    foreach (byte b in utf8Bytes)
                    {
                        sb.Append($"\\x{b:X2}");
                    }
                }
            }
            sb.AppendLine("\";");
            sb.AppendLine();

            // 计算每个字符的字节数
            int bytesPerChar = CalculateBytesPerChar(metadata);

            // 字符点阵数据二维数组
            sb.AppendLine($"static const unsigned char m_char_bits[FONT_CHAR_COUNT][{bytesPerChar}] =");
            sb.AppendLine("{");

            for (int i = 0; i < charCount; i++)
            {
                var charInfo = characters[i];
                char ch = charInfo.Character;
                byte[] pixelData = GetCharacterBytes(charInfo, bytesPerChar);

                // 字符注释
                string charDesc = GetCharacterDescription(ch);
                sb.AppendLine($"    // U+{(int)ch:X4}({charDesc})");

                // 生成十六进制数据行
                sb.Append("    { ");
                for (int j = 0; j < bytesPerChar; j++)
                {
                    if (j > 0)
                    {
                        sb.Append(", ");
                        // 每16字节换行对齐
                        if (j % 16 == 0)
                        {
                            sb.AppendLine();
                            sb.Append("      ");
                        }
                    }
                    sb.Append($"0x{pixelData[j]:X2}");
                }

                if (i < charCount - 1)
                    sb.AppendLine(" },");
                else
                    sb.AppendLine(" }");
            }

            sb.AppendLine("};");

            return sb.ToString();
        }

        /// <summary>
        /// 计算每个字符需要的字节数
        /// </summary>
        private int CalculateBytesPerChar(FontMetadata metadata)
        {
            int totalBits = metadata.MaxCharacterWidth * metadata.MaxCharacterHeight * metadata.BitsPerPixel;
            return (totalBits + 7) / 8; // 向上取整到字节边界
        }

        /// <summary>
        /// 获取字符的字节数据，不足的部分用0填充
        /// </summary>
        private byte[] GetCharacterBytes(CharacterBitmapResult charInfo, int requiredBytes)
        {
            byte[] sourceData = charInfo.GetBitmapBytes();
            byte[] result = new byte[requiredBytes];
            
            int copyLength = Math.Min(sourceData.Length, requiredBytes);
            Array.Copy(sourceData, 0, result, 0, copyLength);
            
            return result;
        }

        /// <summary>
        /// 生成读取多字节数据的C代码
        /// </summary>
        private void GenerateReadBytesCode(StringBuilder sb, string varName, int byteCount)
        {
            sb.Append($"    {varName} = ");
            for (int i = 0; i < byteCount; i++)
            {
                if (i > 0) sb.Append(" | ");
                sb.Append($"(ptr[{i}] << {i * 8})");
            }
            sb.AppendLine(";");
            sb.AppendLine($"    ptr += {byteCount};");
        }

        /// <summary>
        /// 获取字符的描述文本，用于注释
        /// </summary>
        private string GetCharacterDescription(char ch)
        {
            if (ch >= 32 && ch <= 126)
            {
                // 可显示ASCII字符
                return ch switch
                {
                    '"' => "\\\"",
                    '\\' => "\\\\",
                    _ => ch.ToString()
                };
            }
            else
            {
                // 控制字符或扩展字符
                return ch switch
                {
                    '\0' => "NULL",
                    '\n' => "LF",
                    '\r' => "CR",
                    '\t' => "TAB",
                    ' ' => "SPACE",
                    _ => $"0x{(int)ch:X2}"
                };
            }
        }
    }
}